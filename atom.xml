<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jwxhhxx.github.io/</id>
    <title>Summer/JWX</title>
    <updated>2019-06-17T06:47:00.430Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jwxhhxx.github.io/"/>
    <link rel="self" href="https://jwxhhxx.github.io//atom.xml"/>
    <subtitle>宝剑尚未配妥，转身已是江湖</subtitle>
    <logo>https://jwxhhxx.github.io//images/avatar.png</logo>
    <icon>https://jwxhhxx.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Summer/JWX</rights>
    <entry>
        <title type="html"><![CDATA[JS中的各种width]]></title>
        <id>https://jwxhhxx.github.io//post/js-zhong-de-ge-chong-width</id>
        <link href="https://jwxhhxx.github.io//post/js-zhong-de-ge-chong-width">
        </link>
        <updated>2019-06-17T06:33:55.000Z</updated>
        <content type="html"><![CDATA[<p>网页可见区域宽： document.body.clientWidth;
网页可见区域高： document.body.clientHeight;
网页可见区域宽： document.body.offsetWidth   (包括边线的宽);
网页可见区域高： document.body.offsetHeight  (包括边线的宽);
网页正文全文宽： document.body.scrollWidth;
网页正文全文高： document.body.scrollHeight;
网页被卷去的高： document.body.scrollTop;
网页被卷去的左： document.body.scrollLeft;
网页正文部分上： window.screenTop;
网页正文部分左： window.screenLeft;
屏幕分辨率的高： window.screen.height;
屏幕分辨率的宽： window.screen.width;
屏幕可用工作区高度： window.screen.availHeight;
屏幕可用工作区宽度：window.screen.availWidth;</p>
<p><strong>1、offsetWidth width+padding+border)</strong></p>
<p>当前对象的宽度。</p>
<p>style.width也是当前对象的宽度(width+padding+border)。</p>
<p>区别：1)style.width返回值除了数字外还带有单位px；</p>
<pre><code>       2)如对象的宽度设定值为百分比宽度,则无论页面变大还是变小，

          style.width都返回此百分比,而offsetWidth则返回在不同页面中对象的宽度值而不是百分比值；

       3)如果没有给 HTML 元素指定过 width样式，则 style.width 返回的是空字符串；
</code></pre>
<p><strong>2、offsetHeight :(Height+padding+border)</strong></p>
<p>当前对象的高度。</p>
<p>style.height也是当前对象的高度(height+padding+border)。</p>
<p>区别：1)style.height返回值除了数字外还带有单位px；</p>
<pre><code>       2)如对象的高度设定值为百分比高度,则无论页面变高还是变矮，

          style.height都返回此百分比,而offsetHeight则返回在不同页面中对象的高度值而不是百分比值；

       3)如果没有给 HTML 元素指定过 height样式，则 style.height返回的是空字符串；
</code></pre>
<p><strong>3、offsetLeft :</strong></p>
<p>当前对象到其上级层左边的距离。</p>
<p>不能对其进行赋值.设置对象到其上级层左边的距离请用style.left属性。</p>
<p>style.left当前对象到其上级层左边的距离。</p>
<p>区别：1)style.left返回值除了数字外还带有单位px；</p>
<pre><code>       2)如对象到其上级层左边的距离设定值为百分比，

          style.left返回此百分比,而offsetLeft则返回到其上级层左边的距离的值；

       3)如果没有给 HTML 元素指定过 left样式，则 style.left返回的是空字符串；
</code></pre>
<p><strong>4、offsetTop :</strong></p>
<p>当前对象到其上级层顶部边的距离。</p>
<p>不能对其进行赋值.设置对象到上级层顶部边的距离请用style.top属性。</p>
<p>style.top当前对象到其上级层顶部边的距离。</p>
<p>区别：1)style.top返回值除了数字外还带有单位px；</p>
<pre><code>       2)如对象到其上级层顶部边的距离设定值为百分比，

          style.top返回此百分比,而offsetTop则返回到其上级顶部边的距离的值；

       3)如果没有给 HTML 元素指定过 top样式，则 style.top返回的是空字符串；
</code></pre>
<p>注意：如果上级层为body，由于IE、FF对padding、margin的解释不一样所以要明确规定处理不是下列的区别就不成立了。</p>
<p>IE   1)如果Div的上级层是body，而div与body之间有个div，如body-&gt;div-&gt;divo；divo的offsetTop=div的padding+margin+boder；</p>
<pre><code>   2）如果Div的上级层是body，如body&gt;divo；divo的offsetTop=div的padding+margin+boder；

         这divo的offsetTop=divo的margin &gt;body.padding则为divo的margin，否则为body.padding谁大是谁？
</code></pre>
<p>FF  上述两种情况：offsetTop=margin+padding ;</p>
<p>(IE与FF中的body默认padding为10)在IE6.0 FF3.6.13</p>
<p>5、scrollWidth:获取对象的滚动宽度 。</p>
<p>6、scrollHeight: 获取对象的滚动高度。</p>
<p>7、scrollLeft:设置或获取位于对象左边界和对象中目前可见内容的最左端之间的距离(width+padding为一体)</p>
<p>8、scrollTop:设置或获取位于对象最顶端和对象中可见内容的最顶端之间的距离；(height+padding为一体)</p>
<p>9、clientWidth: 获取对象可见内容的宽度，不包括滚动条，不包括边框；</p>
<p>10、clientHeight: 获取对象可见内容的高度，不包括滚动条，不包括边框；</p>
<p>11、clientLeft: 获取对象的border宽度</p>
<p>12、clientTop：获取对象的border高度</p>
<p>13、offsetParent :当前对象的上级层对象.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于JS的IIFE]]></title>
        <id>https://jwxhhxx.github.io//post/guan-yu-js-de-iife</id>
        <link href="https://jwxhhxx.github.io//post/guan-yu-js-de-iife">
        </link>
        <updated>2019-06-17T06:26:22.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1定义">1.定义</h1>
<p>IIFE: Immediately Invoked Function Expression，意为立即调用的函数表达式，也就是说，声明函数的同时立即调用这个函数。
对比一下，这是不采用IIFE时的函数声明和函数调用：</p>
<pre><code>function foo(){
  var a = 10;
  console.log(a);
}
 
foo();
</code></pre>
<p>下面是IIFE形式的函数调用：</p>
<pre><code>(functionfoo(){
  vara=10;
  console.log(a);
})();
</code></pre>
<p>函数的声明和IIFE的区别在于，在函数的声明中，我们首先看到的是function关键字，而IIFE我们首先看到的是左边的（。也就是说，使用一对（）将函数的声明括起来，使得JS编译器不再认为这是一个函数声明，而是一个IIFE，即需要立刻执行声明的函数。
两者达到的目的是相同的，都是声明了一个函数foo并且随后调用函数foo。</p>
<h1 id="2使用iife的好处">2使用IIFE的好处</h1>
<p>如果只是为了立即执行一个函数，显然IIFE所带来的好处有限。实际上，IIFE的出现是为了弥补JS在scope方面的缺陷：JS只有全局作用域（global scope）、函数作用域（function scope），从ES6开始才有块级作用域（block scope）。对比现在流行的其他面向对象的语言可以看出，JS在访问控制这方面是多么的脆弱！那么如何实现作用域的隔离呢？在JS中，只有function才能实现作用域隔离，因此如果要将一段代码中的变量、函数等的定义隔离出来，只能将这段代码封装到一个函数中。
在我们通常的理解中，将代码封装到函数中的目的是为了复用。在JS中，当然声明函数的目的在大多数情况下也是为了复用，但是JS迫于作用域控制手段的贫乏，我们也经常看到只使用一次的函数：这通常的目的是为了隔离作用域了！既然只使用一次，那么立即执行好了！既然只使用一次，函数的名字也省掉了！这就是IIFE的由来。</p>
<h1 id="3-iife的常见形式">3 IIFE的常见形式</h1>
<pre><code>(function foo(){
  var a = 10;
  console.log(a);
})();
</code></pre>
<h1 id="4-iife的函数名和参数">4 IIFE的函数名和参数</h1>
<p>IIFE确实只执行一次，给IIFE起个名字有些画蛇添足了。如果非要给IIFE起个名字，干脆就叫IIFE好了。
IIFE可以带（多个）参数，比如下面的形式：</p>
<pre><code>var a = 2;
(function IIFE(global){
    var a = 3;
    console.log(a); // 3
    console.log(global.a); // 2
})(window);
 
console.log(a); // 2
</code></pre>
<h1 id="小结">小结</h1>
<p>IIFE的目的是为了隔离作用域，防止污染全局命名空间。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ javascript中报Uncaught ReferenceError: XXX is not defined]]></title>
        <id>https://jwxhhxx.github.io//post/javascript-zhong-bao-uncaught-referenceerror-xxx-is-not-defined</id>
        <link href="https://jwxhhxx.github.io//post/javascript-zhong-bao-uncaught-referenceerror-xxx-is-not-defined">
        </link>
        <updated>2019-06-17T05:09:56.000Z</updated>
        <content type="html"><![CDATA[<p><strong>在写javascript函数的时候，JavaScript写在哪里？通常有三种形式：</strong></p>
<ol>
<li>内部：Html网页的<body></body>中；</li>
<li>内部：Html网页的<head></head>中；</li>
<li>外部：外部JS文件里。</li>
<li></li>
</ol>
<p>(1) 写在<body></body>中
当浏览器载入网页Body部分的时候，就执行其中的Javascript语句，执行之后输出的内容就显示在网页中。
(2)写在<head></head>中
当不希望一载入HTML就运行javascript时，而是通过触发事件，这使通常将Javascript放在HTML的<head></head>里。
（3）引入外部的js文件。
刚开始学习的时候，有时候会遇到未定义的情况，那么有哪些原因会导致这种情况呢？
  1）JS函数未定义。（这种低级的相信大家都不会犯，但是不排除定义的函数和声明的函数名称不一致的情况，或     者传入参数不一致）
  2）将Javascript函数放在了body和head之外了。
  3）Javascript函数定义在对象声明之前。你的代码是直接就能运行的话,要是代码所操作的对象在代码后面,有的   浏览器会返回错误.因为它们是按顺序加载对象。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://jwxhhxx.github.io//post/hello-gridea</id>
        <link href="https://jwxhhxx.github.io//post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="http://hvenotes.fehey.com/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>𝖶𝗂𝗇𝖽𝗈𝗐𝗌</strong> 或 <strong>𝖬𝖺𝖼𝖮𝖲</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>